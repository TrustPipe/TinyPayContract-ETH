{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-c5b6fd5d6a78418d2661a43b0aa8b28ae301b648",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/TinyPay.sol": "project/contracts/TinyPay.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/TinyPay.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\ncontract TinyPay {\n    uint256 public totalDeposits;\n    uint256 public totalWithdrawals;\n    uint64  public feeRate;     // basis points (100 = 1%)\n    address public admin;\n    address public paymaster;\n    bool    public initialized;\n\n    struct UserAccount {\n        uint256 balance;          // in wei\n        bytes32 tail;             // current tail\n        uint64  paymentLimit;     // 0 = unlimited\n        uint64  tailUpdateCount;  // how many times tail changed\n        uint64  maxTailUpdates;   // 0 = unlimited\n    }\n\n    struct PreCommit {\n        address merchant;\n        uint64  expiryTime;       // unix seconds\n    }\n\n    mapping(address => UserAccount) private accounts;\n    mapping(bytes32 => PreCommit)  private precommits;\n\n    event AccountInitialized(address indexed user);\n    event DepositMade(address indexed user, uint256 amount, bytes32 tail, uint256 newBalance, uint64 timestamp);\n    event PreCommitMade(address indexed merchant, bytes32 commitHash, uint64 expiryTime);\n    event PaymentCompleted(address indexed payer, address indexed recipient, uint256 amount, uint256 fee, bytes32 newTail, uint64 timestamp);\n    event PaymentLimitUpdated(address indexed user, uint64 oldLimit, uint64 newLimit, uint64 timestamp);\n    event TailUpdatesLimitSet(address indexed user, uint64 oldLimit, uint64 newLimit, uint64 timestamp);\n    event TailRefreshed(address indexed user, bytes32 oldTail, bytes32 newTail, uint64 tailUpdateCount, uint64 timestamp);\n    event FundsAdded(address indexed user, uint256 amount, uint256 newBalance, uint64 timestamp);\n    event FundsWithdrawn(address indexed user, uint256 amount, uint256 newBalance, uint64 timestamp);\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"NOT_ADMIN\");\n        _;\n    }\n\n    modifier onlyInitialized() {\n        require(initialized, \"NOT_INIT\");\n        _;\n    }\n\n    receive() external payable {\n        revert(\"DIRECT_ETH_DISABLED\");\n    }\n\n    // Initialize once after deploy\n    function initSystem(address _paymaster, uint64 _feeRate) external {\n        require(!initialized, \"ALREADY_INIT\");\n        admin = msg.sender;\n        paymaster = _paymaster;\n        feeRate = _feeRate;\n        initialized = true;\n    }\n\n    // payable deposit; auto-inits account and optionally sets tail\n    function deposit(bytes32 tail) public payable onlyInitialized {\n        require(msg.value > 0, \"INVALID_AMOUNT\");\n\n        UserAccount storage a = accounts[msg.sender];\n        bool fresh = (a.balance == 0 && a.tail == bytes32(0) && a.paymentLimit == 0 && a.tailUpdateCount == 0 && a.maxTailUpdates == 0);\n        if (fresh) {\n            emit AccountInitialized(msg.sender);\n        }\n\n        if (tail != bytes32(0) && tail != a.tail) {\n            a.tailUpdateCount += 1;\n            a.tail = tail;\n        }\n\n        a.balance += msg.value;\n        totalDeposits += msg.value;\n\n        emit DepositMade(msg.sender, msg.value, a.tail, a.balance, uint64(block.timestamp));\n    }\n\n    // Add funds without touching tail\n    function addFunds() external payable onlyInitialized {\n        require(msg.value > 0, \"INVALID_AMOUNT\");\n        UserAccount storage a = accounts[msg.sender];\n        bool fresh = (a.balance == 0 && a.tail == bytes32(0) && a.paymentLimit == 0 && a.tailUpdateCount == 0 && a.maxTailUpdates == 0);\n        if (fresh) {\n            emit AccountInitialized(msg.sender);\n        }\n        a.balance += msg.value;\n        totalDeposits += msg.value;\n        emit FundsAdded(msg.sender, msg.value, a.balance, uint64(block.timestamp));\n    }\n\n    // Merchant pre-commit; expires in 15 minutes\n    function merchantPrecommit(bytes32 commitHash) external onlyInitialized {\n        require(commitHash != bytes32(0), \"INVALID_COMMIT\");\n        require(precommits[commitHash].merchant == address(0), \"COMMIT_EXISTS\");\n\n        uint64 expiry = uint64(block.timestamp + 15 minutes);\n        precommits[commitHash] = PreCommit({ merchant: msg.sender, expiryTime: expiry });\n\n        emit PreCommitMade(msg.sender, commitHash, expiry);\n    }\n\n    // Complete payment; paymaster can bypass commit checks\n    // Check: sha256(opt) must equal payer.tail\n    function completePayment(\n        bytes32 opt,\n        address payer,\n        address payable recipient,\n        uint256 amount,\n        bytes32 commitHash\n    ) external onlyInitialized {\n        require(amount > 0, \"INVALID_AMOUNT\");\n        UserAccount storage a = accounts[payer];\n        require(a.balance >= amount, \"INSUFFICIENT_BALANCE\");\n\n        bool isPaymaster = (msg.sender == paymaster);\n        if (!isPaymaster) {\n            bytes32 computed = sha256(abi.encode(payer, recipient, amount, opt));\n            require(computed == commitHash, \"INVALID_PRECOMMIT_HASH\");\n            PreCommit memory pc = precommits[commitHash];\n            require(pc.merchant != address(0), \"PRECOMMIT_NOT_FOUND\");\n            require(block.timestamp <= pc.expiryTime, \"PRECOMMIT_EXPIRED\");\n            delete precommits[commitHash];\n        }\n\n        // Verify sha256(opt) matches current tail\n        bytes32 optHash = sha256(abi.encodePacked(opt));\n        require(optHash == a.tail, \"INVALID_OPT\");\n\n        // Limits\n        if (a.paymentLimit > 0) {\n            require(amount <= a.paymentLimit, \"PAYMENT_LIMIT\");\n        }\n        if (a.maxTailUpdates > 0) {\n            require(a.tailUpdateCount < a.maxTailUpdates, \"TAIL_UPDATES_LIMIT\");\n        }\n\n        // Effects\n        uint256 fee = (amount * feeRate) / 10000;\n        uint256 toRecipient = amount - fee;\n\n        a.balance -= amount;\n        a.tail = opt; // advance tail\n        a.tailUpdateCount += 1;\n\n        totalWithdrawals += amount;\n\n        // Interaction\n        (bool ok, ) = recipient.call{value: toRecipient}(\"\");\n        require(ok, \"TRANSFER_FAIL\");\n\n        emit PaymentCompleted(payer, recipient, amount, fee, opt, uint64(block.timestamp));\n    }\n\n    // User config\n    function setPaymentLimit(uint64 limit) external onlyInitialized {\n        UserAccount storage a = accounts[msg.sender];\n        uint64 old = a.paymentLimit;\n        a.paymentLimit = limit;\n        emit PaymentLimitUpdated(msg.sender, old, limit, uint64(block.timestamp));\n    }\n\n    function setTailUpdatesLimit(uint64 limit) external onlyInitialized {\n        UserAccount storage a = accounts[msg.sender];\n        uint64 old = a.maxTailUpdates;\n        a.maxTailUpdates = limit;\n        emit TailUpdatesLimitSet(msg.sender, old, limit, uint64(block.timestamp));\n    }\n\n    function refreshTail(bytes32 newTail) external onlyInitialized {\n        UserAccount storage a = accounts[msg.sender];\n        if (a.maxTailUpdates > 0) {\n            require(a.tailUpdateCount < a.maxTailUpdates, \"TAIL_UPDATES_LIMIT\");\n        }\n        bytes32 oldTail = a.tail;\n        if (newTail != oldTail) {\n            a.tail = newTail;\n            a.tailUpdateCount += 1;\n        }\n        emit TailRefreshed(msg.sender, oldTail, newTail, a.tailUpdateCount, uint64(block.timestamp));\n    }\n\n    // Withdraw user funds\n    function withdrawFunds(uint256 amount) external onlyInitialized {\n        require(amount > 0, \"INVALID_AMOUNT\");\n        UserAccount storage a = accounts[msg.sender];\n        require(a.balance >= amount, \"INSUFFICIENT_BALANCE\");\n\n        a.balance -= amount;\n        totalWithdrawals += amount;\n\n        (bool ok, ) = payable(msg.sender).call{value: amount}(\"\");\n        require(ok, \"TRANSFER_FAIL\");\n\n        emit FundsWithdrawn(msg.sender, amount, a.balance, uint64(block.timestamp));\n    }\n\n    // Admin\n    function updateFeeRate(uint64 newFeeRate) external onlyAdmin {\n        feeRate = newFeeRate;\n    }\n\n    function setPaymaster(address newPaymaster) external onlyAdmin {\n        paymaster = newPaymaster;\n    }\n\n    function withdrawFee(address payable to, uint256 amount) external onlyAdmin {\n        (bool ok, ) = to.call{value: amount}(\"\");\n        require(ok, \"FEE_WITHDRAW_FAIL\");\n    }\n\n    // Views\n    function getBalance(address user) external view returns (uint256) {\n        return accounts[user].balance;\n    }\n\n    function getUserTail(address user) external view returns (bytes32) {\n        return accounts[user].tail;\n    }\n\n    // (paymentLimit, tailUpdateCount, maxTailUpdates)\n    function getUserLimits(address user) external view returns (uint64, uint64, uint64) {\n        UserAccount memory a = accounts[user];\n        return (a.paymentLimit, a.tailUpdateCount, a.maxTailUpdates);\n    }\n\n    // (totalDeposits, totalWithdrawals, feeRate)\n    function getSystemStats() external view returns (uint256, uint256, uint64) {\n        return (totalDeposits, totalWithdrawals, feeRate);\n    }\n\n    function isAccountInitialized(address user) external view returns (bool) {\n        UserAccount memory a = accounts[user];\n        return (a.balance > 0 || a.tail != bytes32(0) || a.paymentLimit > 0 || a.tailUpdateCount > 0 || a.maxTailUpdates > 0);\n    }\n\n    function getVaultAddress() external view returns (address) {\n        return address(this);\n    }\n}\n"
      }
    }
  }
}